/*
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入:
[0,1,0,3,12]

输出:
[1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。

解题思路，只要当前值不为0，就把当前值赋给当前值，k和i 向后移动。
当出现值为0时，k不变，i加1，然后判断nums[i]是否为0，如果不是0，把
i下标对应的值，赋给前面k位置的值，即不为0的值向前移动了，k++。继续向后遍历，
最终K后面的值都是需要置为0
*/
#include <iostream>
#include <vector>
using namespace  std;
void move_zero(vector<int> &nums) {
	int k = 0;
	for (int i =0 ;i < nums.size(); ++i)
	{
		if (nums[i])
		{
			nums[k++] = nums[i];
		}
	}
	for (int j =k ; j<nums.size(); ++j)
	{
		nums[j] = 0;
	}

}
int main()
{
	for (int i = 0; i < 5; i = 3)
	{
		cout << i << endl;
		break;
	}
	vector<int> vec = { 1,0,2,3,12 };
	move_zero(vec);
	for (auto value :vec)
	{
		cout << value << ",";
	}
	getchar();
	return 0;
}
